from __future__ import annotations

import json
from pathlib import Path
from typing import Any
from datetime import datetime

import pandas as pd

from .fundamental_filter import FundamentalView


def _read_csv_if_exists(path: Path) -> list[dict[str, Any]] | None:
    """Read a CSV into JSON-serialisable records. Returns None if missing."""
    if path is None or (not path.exists()):
        return None
    df = pd.read_csv(path)
    if df.empty:
        return []
    df = df.where(pd.notnull(df), None)
    return df.to_dict(orient="records")


def _read_annual_returns(path: Path, as_of: str | None) -> list[dict[str, Any]] | None:
    if not path.exists():
        return None
    df = pd.read_csv(path, index_col=0)
    if df.empty:
        return []

    as_of_date = None
    if as_of and isinstance(as_of, str):
        ao = as_of.strip()
        if ao and ao.lower() not in ("latest", "none"):
            try:
                as_of_date = datetime.strptime(ao, "%Y-%m-%d").date()
            except Exception:
                as_of_date = None

    last_year = int(df.index.max())
    out = []
    for year, row in df.iterrows():
        y = int(year)
        label = f"{y}"
        if as_of_date and y == last_year and as_of_date.year == y and (as_of_date.month, as_of_date.day) != (12, 31):
            label = f"{y} YTD (through {as_of_date.isoformat()})"
        item = {"year": y, "label": label}
        for col, val in row.items():
            item[col] = val
        out.append(item)
    return out


def build_report_payload(
    *,
    ticker: str,
    outputs_dir: str | Path,
    run_params: dict[str, Any],
    fundamental_view: FundamentalView | None = None,
) -> dict[str, Any]:
    out_dir = Path(outputs_dir)
    main_dir = out_dir / "main"
    app_dir = out_dir / "appendix"

    # Try to find files produced by report_block
    def pick_one(folder: Path, pattern: str) -> Path | None:
        matches = sorted(folder.glob(pattern))
        return matches[0] if matches else None

    main_metrics = pick_one(main_dir, "*_metrics.csv")
    main_annual = pick_one(main_dir, "*_annual_returns.csv")
    app_metrics = pick_one(app_dir, "*_metrics.csv")
    app_annual = pick_one(app_dir, "*_annual_returns.csv")

    # Sensitivity analysis table (if generated by run_demo)
    sens_csv = app_dir / "FULL_sensitivity.csv"

    main_figs = sorted([p.name for p in main_dir.glob("*.png")])
    app_figs = sorted([p.name for p in app_dir.glob("*.png")])
    main_csvs = sorted([p.name for p in main_dir.glob("*.csv")])
    app_csvs = sorted([p.name for p in app_dir.glob("*.csv")])

    # Return definition (for report transparency)
    # Prefer yfinance_meta (produced by data layer) but fall back to any direct run_params field.
    ymeta = run_params.get("yfinance_meta", {}) if isinstance(run_params, dict) else {}
    return_definition = None
    if isinstance(ymeta, dict):
        return_definition = ymeta.get("return_definition")
    if not return_definition and isinstance(run_params, dict):
        return_definition = run_params.get("return_definition")

    as_of = run_params.get("as_of") if isinstance(run_params, dict) else None

    # Authoritative strategy specification (for LLM fidelity). Keep it concise and factual.
    best_main = run_params.get("best_params_val") if isinstance(run_params, dict) else None
    best_main = best_main if isinstance(best_main, dict) else {}
    strat_spec_main = {
        "scope": "Main strategy only (use_patterns=False). Long/flat only; no short selling.",
        "trend_filter": {
            "name": "EMA crossover gate",
            "ema_fast": best_main.get("ema_fast"),
            "ema_slow": best_main.get("ema_slow"),
            "rule": "trend_up = (EMA_fast > EMA_slow)",
            "weight_in_score": 2,
        },
        "confirmations": [
            {"name": "Pullback", "rule": "close < BB_mid * 1.01", "weight_in_score": 1},
            {"name": "RSI strength", "rule": "RSI(14) > 45", "weight_in_score": 1},
            {"name": "MACD momentum", "rule": "MACD_hist > 0", "weight_in_score": 1},
        ],
        "score": {
            "rule": "long_score = 2*trend_up + confirm_count (confirm_count is the number of confirmations true)",
            "range": [0, 5],
        },
        "hysteresis_state_machine": {
            "entry_threshold": 4,
            "hold_threshold": 2,
            "when_flat": "enter long if long_score >= entry_threshold",
            "when_long": "remain long if long_score >= hold_threshold; otherwise exit to flat",
        },
        "execution_timing": {
            "decision_time": "signals/target position are computed on the bar close",
            "execution": "executed next bar via a 1-bar delay inside run_backtest()",
        },
        "regime": {
            "type": "3-state",
            "buffer_pct": best_main.get("regime_buffer_pct"),
            "rule": "regime=1 if close > EMA_slow*(1+buffer); regime=-1 if close < EMA_slow*(1-buffer); else 0",
        },
        "base_exposure_mapping": {
            "bull": "if signal_bin=1 and regime=1 -> 1.0; else 0.0",
            "neutral": "if signal_bin=1 and regime=0 -> 0.5; else 0.0",
            "bear": "if regime=-1: only allow 0.25 when signal_bin=1 AND long_score==5; otherwise 0.0",
        },
        "risk_management": {
            "vol_targeting": {
                "target_vol": run_params.get("target_vol") if isinstance(run_params, dict) else None,
                "vol_window": best_main.get("vol_window"),
                "note": "position_target = base_position * leverage; leverage ~= target_vol / realized_vol, clipped by leverage caps",
            },
            "transaction_cost": {
                "trading_cost": run_params.get("trading_cost") if isinstance(run_params, dict) else None,
                "model": "strategy_ret = position_exec * ret - trading_cost * turnover",
            },
            "fundamental_overlay": {
                "mode": run_params.get("fundamental_mode") if isinstance(run_params, dict) else None,
                "sell_leverage_mult": run_params.get("sell_leverage_mult") if isinstance(run_params, dict) else None,
                "policy": "risk filter only; does not change entry/exit logic; SELL can cap max leverage",
            },
        },
        "appendix_experiments": {
            "volume_confirm": "Entry-only relative-volume gate (experimental). Not part of main strategy unless explicitly enabled.",
            "patterns": "Candlestick/pattern features (experimental). Not part of main strategy unless explicitly enabled.",
        },
    }

    payload: dict[str, Any] = {
        "ticker": ticker,
        "run_params": run_params,
        "return_definition": return_definition,
        "strategy_spec_main": strat_spec_main,
        "figures_main": main_figs,
        "figures_appendix": app_figs,
        "fundamental_overlay": (None if fundamental_view is None else {
            "rating": fundamental_view.rating_norm,
            "as_of": fundamental_view.as_of,
            "source": fundamental_view.source,
            "notes": fundamental_view.notes,
        }),
        # Backward-compatible alias used by some prompts/tools
        "fundamental_view": (None if fundamental_view is None else {
            "rating": fundamental_view.rating_norm,
            "as_of": fundamental_view.as_of,
            "source": fundamental_view.source,
            "notes": fundamental_view.notes,
        }),
        "outputs": {
            "main": {
                "dir": str(main_dir),
                "figures": main_figs,
                "csv_files": main_csvs,
                "metrics": _read_csv_if_exists(main_metrics) if main_metrics else None,
                "annual_returns": _read_annual_returns(main_annual, as_of) if main_annual else None,
            },
            "appendix": {
                "dir": str(app_dir),
                "figures": app_figs,
                "csv_files": app_csvs,
                "sensitivity": _read_csv_if_exists(sens_csv),
                "metrics": _read_csv_if_exists(app_metrics) if app_metrics else None,
                "annual_returns": _read_annual_returns(app_annual, as_of) if app_annual else None,
            },
        },
        "instructions": [
            f"Return definition: {return_definition}",
            "Do not invent numbers. Use only provided metrics/annual returns.",
            "Reference figures by filename (e.g., FULL_equity.png).",
            "Explain execution timing: position is decision-time and is shifted inside backtest.",
            "If fundamental overlay is provided, treat it as a filter/overlay and clearly state whether it was used in backtest.",
        ],
    }
    return payload


def save_report_payload(payload: dict[str, Any], path: str | Path) -> Path:
    """
    Save report payload as JSON to given path.
    """
    p = Path(path)
    p.parent.mkdir(parents=True, exist_ok=True)

    # IMPORTANT: actually write to file
    p.write_text(json.dumps(payload, indent=2, default=str), encoding="utf-8")

    return p
